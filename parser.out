Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    AND
    AS
    BREAK
    CASE
    CATCH
    COLON
    CONST
    CONTINUE
    DEFAULT
    DELETE
    DIVIDE
    DIVIDE_ASSIGN
    DO
    DOT
    ELSE
    EQUAL
    EXPORT
    EXTENDS
    FINALLY
    FOR
    FROM
    FUNCTION
    GREATER
    GREATER_EQUAL
    IF
    IMPLEMENTS
    IMPORT
    IN
    INSTANCEOF
    LBRACKET
    LESS
    LESS_EQUAL
    LET
    MINUS
    MINUS_ASSIGN
    MODULO
    MODULO_ASSIGN
    MULTIPLY
    MULTIPLY_ASSIGN
    NEW
    NOT
    NOT_EQUAL
    NUMBER
    OR
    PLUS
    PLUS_ASSIGN
    QUESTION_MARK
    RBRACKET
    RETURN
    STRICT_EQUAL
    SUPER
    SWITCH
    THIS
    THROW
    TRY
    TYPEOF
    VAR
    VOID
    WHILE

Grammar

Rule 0     S' -> input
Rule 1     input -> VARIABLE ASSIGN INPUT LPAREN RPAREN
Rule 2     program -> statements
Rule 3     statements -> statement
Rule 4     statements -> statement statements
Rule 5     statement -> print
Rule 6     statement -> structure_declaration
Rule 7     statement -> input
Rule 8     statement -> error
Rule 9     print -> PRINT LPAREN arguments RPAREN SEMICOLON
Rule 10    arguments -> argument
Rule 11    arguments -> argument COMMA arguments
Rule 12    argument -> STRING
Rule 13    argument -> VARIABLE
Rule 14    structure_declaration -> CLASS VARIABLE LBRACE statements RBRACE

Terminals, with rules where they appear

AND                  : 
AS                   : 
ASSIGN               : 1
BREAK                : 
CASE                 : 
CATCH                : 
CLASS                : 14
COLON                : 
COMMA                : 11
CONST                : 
CONTINUE             : 
DEFAULT              : 
DELETE               : 
DIVIDE               : 
DIVIDE_ASSIGN        : 
DO                   : 
DOT                  : 
ELSE                 : 
EQUAL                : 
EXPORT               : 
EXTENDS              : 
FINALLY              : 
FOR                  : 
FROM                 : 
FUNCTION             : 
GREATER              : 
GREATER_EQUAL        : 
IF                   : 
IMPLEMENTS           : 
IMPORT               : 
IN                   : 
INPUT                : 1
INSTANCEOF           : 
LBRACE               : 14
LBRACKET             : 
LESS                 : 
LESS_EQUAL           : 
LET                  : 
LPAREN               : 1 9
MINUS                : 
MINUS_ASSIGN         : 
MODULO               : 
MODULO_ASSIGN        : 
MULTIPLY             : 
MULTIPLY_ASSIGN      : 
NEW                  : 
NOT                  : 
NOT_EQUAL            : 
NUMBER               : 
OR                   : 
PLUS                 : 
PLUS_ASSIGN          : 
PRINT                : 9
QUESTION_MARK        : 
RBRACE               : 14
RBRACKET             : 
RETURN               : 
RPAREN               : 1 9
SEMICOLON            : 9
STRICT_EQUAL         : 
STRING               : 12
SUPER                : 
SWITCH               : 
THIS                 : 
THROW                : 
TRY                  : 
TYPEOF               : 
VAR                  : 
VARIABLE             : 1 13 14
VOID                 : 
WHILE                : 
error                : 8

Nonterminals, with rules where they appear

argument             : 10 11
arguments            : 9 11
input                : 7 0
print                : 5
program              : 
statement            : 3 4
statements           : 2 4 14
structure_declaration : 6

Parsing method: LALR

state 0

    (0) S' -> . input
    (1) input -> . VARIABLE ASSIGN INPUT LPAREN RPAREN

    VARIABLE        shift and go to state 2

    input                          shift and go to state 1

state 1

    (0) S' -> input .



state 2

    (1) input -> VARIABLE . ASSIGN INPUT LPAREN RPAREN

    ASSIGN          shift and go to state 3


state 3

    (1) input -> VARIABLE ASSIGN . INPUT LPAREN RPAREN

    INPUT           shift and go to state 4


state 4

    (1) input -> VARIABLE ASSIGN INPUT . LPAREN RPAREN

    LPAREN          shift and go to state 5


state 5

    (1) input -> VARIABLE ASSIGN INPUT LPAREN . RPAREN

    RPAREN          shift and go to state 6


state 6

    (1) input -> VARIABLE ASSIGN INPUT LPAREN RPAREN .

    $end            reduce using rule 1 (input -> VARIABLE ASSIGN INPUT LPAREN RPAREN .)

